import { useCallback, useEffect, useRef, useState } from "react"
import { fetchWeatherApi } from "openmeteo"
import "./App.css"
import Carousel from "./components/Carousel/Carousel"
import Nav from "./components/Nav/Nav"
import StarRating from "./components/StarRating/StarRating"
import DateGroup from "./components/Carousel/DateGroup"
import TempGroup from "./components/Carousel/TempGroup"
import RainGroup from "./components/Carousel/RainGroup"
import WindGroup from "./components/Carousel/WindGroup"
import zip from "./utils/zip"
import indicesArray from "./utils/indicesArray"
import calcStarRating from "./utils/calcStarRating"
import ErrorScreen from "./components/ErrorScreen/ErrorScreen"
import SkeletonCarousel from "./components/Carousel/SkeletonCarousel"
import StartScreen from "./components/StartScreen/StartScreen"
import Forecast from "./types/Forecast"
import Location from "./types/Location"
import BestDay from "./components/BestDay/BestDay"
import SkeletonBestDay from "./components/BestDay/SkeletonBestDay"

const App = () => {
  // States
  const [location, setLocation] = useState<Location>(null)
  const [error, setError] = useState<string | null>(null)
  const [forecast, setForecast] = useState<Forecast>(null)

  // Refs
  const carouselsRef = useRef<HTMLDivElement[]>([])

  // Values
  const forecastDays = 14

  /**
   * Hide the start screen and make it intangible. It has a fade-out animation.
   */
  const hideStartScreen = () => {
    document.getElementById("start-screen")?.classList.add("opacity-0")
    document.getElementById("start-screen")?.classList.add("pointer-events-none")
    document.getElementById("start-screen")?.classList.add("fadeout")
    document.getElementById("start-screen")?.classList.remove("opacity-100")
  }

  /**
   * Register a carousel element to the carouselsRef reference. This will
   * be called during the declaration of <Carousel>s, for example
   * ```
   * <Carousel
   *   ref={(el) => registerCarousel(el)}
   *   onScroll={(e) => handleCarouselScroll(e.target)}
   *   items={...}
   * />
   * ```
   */
  const registerCarousel = useCallback((el: HTMLDivElement | null) => {
    if (el && !carouselsRef.current.includes(el)) {
      carouselsRef.current.push(el)
    }
  }, [])

  /**
   * Handles the scrolling of carousels. This is used to synchronize the scroll positions of carousels.
   * @param scrollingElement The element that is being scrolled
   */
  const handleCarouselScroll = (scrollingElement: HTMLDivElement) => {
    const scrollLeft = scrollingElement.scrollLeft

    // Synchronize scroll positions
    carouselsRef.current.forEach((carousel) => {
      if (carousel !== scrollingElement) {
        carousel.scrollLeft = scrollLeft
      }
    })
  }

  /**
   * Gets the user's location using the browser's geolocation API.
   */
  const getLocation = () => {
    console.log("Get location")
    navigator.geolocation.getCurrentPosition(
      (position: GeolocationPosition) => { setLocation({ latitude: position.coords.latitude, longitude: position.coords.longitude }) },
      (err: GeolocationPositionError) => { setError(err.message) }
    )
  }

  /**
   * Gets the weather forecast for the coming week from Open Meteo. This is
   * a useCallback function that runs when the user's location has been
   * successfully retrieved.
   * 
   * Partially generated by https://open-meteo.com/en/docs
   */
  const getForecast = useCallback(async () => {
    if (location) {
      // Get the locality via reverse geocoding using the bigdatacloud API
      // Since it's the user's device that makes these requests, the limits won't
      // be hit.
      // https://www.bigdatacloud.com/reverse-geocoding
      // https://api-bdc.io/data/reverse-geocode-client?latitude=50.567479&longitude=-2.446&localityLanguage=en
      // The API defaults to ip geolocation when coordinate lookup fails
      const reverseGeoUrl = `https://api-bdc.io/data/reverse-geocode-client?latitude=${location.latitude}&longitude=${location.longitude}&localityLanguage=en`

      const reverseGeocode: {
        locality: string | null,
        principalSubdivision: string | null
      } = await fetch(reverseGeoUrl)
        .then((resp) => resp.json())
        .then((data) => {
          return { locality: data.locality, principalSubdivision: data.principalSubdivision }
        })
        .catch((e) => {
          setError(e.message)
          return { locality: null, principalSubdivision: null }
        })

      // Get the forecast
      const params = {
        "latitude": location.latitude,
        "longitude": location.longitude,
        "daily": ["weather_code", "temperature_2m_max", "temperature_2m_min", "precipitation_probability_mean", "wind_speed_10m_max", "wind_gusts_10m_max", "wind_direction_10m_dominant"],
        "wind_speed_unit": "kn",
        "timezone": "auto",
        "forecast_days": forecastDays,
      }
      const url = "https://api.open-meteo.com/v1/forecast"
      // const url = "https://api.open-meteo.com/v1/forecasnldkalksdhdalsst" // malformed
      const responses = await fetchWeatherApi(url, params)

      // Helper function to form time ranges
      const range = (start: number, stop: number, step: number) =>
        Array.from({ length: (stop - start) / step }, (_, i) => start + i * step)

      // Process first location. Add a for-loop for multiple locations or weather models
      const response = responses[0]

      // Attributes for timezone and location
      const utcOffsetSeconds = response.utcOffsetSeconds()
      // const timezone = response.timezone()
      // const timezoneAbbreviation = response.timezoneAbbreviation()
      // const responseLatitude = response.latitude()
      // const responseLongitude = response.longitude()

      const daily = response.daily()!

      // Note: The order of weather variables in the URL query and the indices below need to match!
      const weatherData = {
        daily: {
          time: range(Number(daily.time()), Number(daily.timeEnd()), daily.interval()).map(
            (t) => new Date((t + utcOffsetSeconds) * 1000)
          ),
          weatherCode: daily.variables(0)!.valuesArray()!,
          temperature2mMax: daily.variables(1)!.valuesArray()!,
          temperature2mMin: daily.variables(2)!.valuesArray()!,
          precipitationProbabilityMean: daily.variables(3)!.valuesArray()!,
          windSpeed10mMax: daily.variables(4)!.valuesArray()!,
          windGusts10mMax: daily.variables(5)!.valuesArray()!,
          windDirection10mDominant: daily.variables(6)!.valuesArray()!,
          sailingRatings: indicesArray(forecastDays).map(() => 0),
          swimmingRatings: indicesArray(forecastDays).map(() => 0),
        },
        locality: reverseGeocode.locality,
        principalSubdivision: reverseGeocode.principalSubdivision
      }

      // Calculate and set ratings (SAILING)
      weatherData.daily.sailingRatings.map((_, i) => {
        weatherData.daily.sailingRatings[i] = calcStarRating(
          true,
          weatherData.daily.windSpeed10mMax[i],
          weatherData.daily.precipitationProbabilityMean[i],
          weatherData.daily.temperature2mMax[i],
          weatherData.daily.temperature2mMin[i],
          weatherData.daily.weatherCode[i]
        )
      })

      // Calculate and set ratings (SWIMMING)
      weatherData.daily.swimmingRatings.map((_, i) => {
        weatherData.daily.swimmingRatings[i] = calcStarRating(
          false,
          weatherData.daily.windSpeed10mMax[i],
          weatherData.daily.precipitationProbabilityMean[i],
          weatherData.daily.temperature2mMax[i],
          weatherData.daily.temperature2mMin[i],
          weatherData.daily.weatherCode[i]
        )
      })

      console.log("Weather data: ", weatherData)
      setForecast(weatherData)
    } else {
      console.error("No location found!")
      setError("Failed to fetch forecast data: No location found!")
    }
  }, [location])

  // Get forecast and hide start screen when location changes
  useEffect(() => {
    if (location) {
      hideStartScreen()
      getForecast()
    }
  }, [location, getForecast])

  // Set location permission to false by default. If the user gives permission,
  // don't show the start screen again.
  useEffect(() => {
    if (window.localStorage.getItem("hasGivenLocationPermission") === null) {
      window.localStorage.setItem("hasGivenLocationPermission", "false")
    } else if (window.localStorage.getItem("hasGivenLocationPermission") === "true") {
      // User granted permission before - Go ahead and get the location
      getLocation()
    }
  }, [])


  return (
    <>
      {/* Error screen covering the whole screen */}
      {
        error
          ? <ErrorScreen className="opacity-100" err={error} />
          : <ErrorScreen className="opacity-0 pointer-events-none" err={""} />
      }
      {/* hide content until the user clicks the get location button */}
      {
        window.localStorage.getItem("hasGivenLocationPermission") === "false" || window.localStorage.getItem("hasGivenLocationPermission") === null
          ? <StartScreen className="opacity-100" getLocation={getLocation} />
          : <StartScreen className="opacity-0 pointer-events-none" getLocation={getLocation} />
      }

      <Nav />

      {/* 
        *
        * RATINGS
        *
        */}
      <div className="card">
        <h1 className="text-xl font-bold">

        </h1>
        <p className={"text-sm" + (forecast && forecast.locality) ? "" : " font-bold"}>
          Here's an overview of the week's weather...
        </p>
        {
          forecast && forecast.locality !== null
            ? <h1 className="text-xl font-bold text-start">{forecast!.locality}, {forecast!.principalSubdivision}</h1>
            : <></>
        }

        <h2 className="text-lg font-medium -mb-2">Sailing</h2>
        {/* <SkeletonCarousel rows={3} cols={forecastDays} /> */}
        { // Render a skeleton if the forecast is not available
          forecast != undefined
            ? <Carousel
              ref={(el) => registerCarousel(el)}
              onScroll={(e) => handleCarouselScroll(e.target as HTMLDivElement)}
              items={
                forecast != undefined
                  // Map over the whole forecast, using an array of [0..forecastDays-1]
                  // to index into the forecast
                  ? indicesArray(forecastDays).map(
                    idx => <StarRating
                      stars={
                        forecast?.daily.sailingRatings[idx]
                      }
                      dayOfWeek={forecast?.daily.time[idx].getDay()}
                    />
                  )
                  : [<code className="hidden">Error: forecast undefined!</code>]
              }
            />
            : <SkeletonCarousel rows={3} cols={forecastDays} />
        }


        <h2 className="text-lg font-medium -mb-2">Swimming</h2>
        { // Render a skeleton if the forecast is not available
          forecast != undefined
            ? <Carousel
              ref={(el) => registerCarousel(el)}
              onScroll={(e) => handleCarouselScroll(e.target as HTMLDivElement)}
              items={
                forecast != undefined
                  // Map over the whole forecast, using an array of [0..forecastDays-1]
                  // to index into the forecast
                  ? indicesArray(forecastDays).map(
                    idx => <StarRating
                      stars={
                        forecast?.daily.swimmingRatings[idx]
                      }
                      dayOfWeek={forecast?.daily.time[idx].getDay()}
                    />
                  )
                  : [<code className="hidden">Error: forecast undefined!</code>]
              }
            />
            : <SkeletonCarousel rows={3} cols={forecastDays} />
        }

      </div >

      {/* Double small previews (temp icons here) - maybe put best days in here */}
      < div className="double-card flex flex-row w-11/12 lg:w-1/2 gap-3" >
        {forecast ? <BestDay forecast={forecast} sailing={true} /> : <SkeletonBestDay />
        }
        {forecast ? <BestDay forecast={forecast} sailing={false} /> : <SkeletonBestDay />}
      </div >

      {/* Main weather forecast section */}
      < div className="card text-center" >
        {/* <button className="btn-secondary" onClick={getLocation}>Get location</button> */}

        < h1 className="text-xl font-bold text-start" >
          Daily weather forecast
        </h1 >

        <hr className="mt-2" />

        {/* 
          *
          * DATES 
          *
          */}
        {
          forecast != undefined ? <Carousel
            ref={(el) => registerCarousel(el)}
            onScroll={(e) => handleCarouselScroll(e.target as HTMLDivElement)}
            items={
              forecast != undefined ? Array.from(forecast?.daily.time).map(item => <DateGroup date={item} />) : [<code className="hidden">Error: forecast undefined!</code>]
            }
          /> : <SkeletonCarousel rows={3} cols={forecastDays} />
        }

        {/* 
          *
          * TEMPERATURES 
          *
          */}
        <p className="text-start text-sm font-bold">Temperature (°C)</p>

        {
          forecast != undefined
            ? <Carousel
              ref={(el) => registerCarousel(el)}
              onScroll={(e) => handleCarouselScroll(e.target as HTMLDivElement)}
              items={
                forecast != undefined
                  // Zip together min and max temperatures
                  ? zip(
                    Array.from(forecast?.daily.temperature2mMax),
                    Array.from(forecast?.daily.temperature2mMin)
                  ).map(([max, min]) => <TempGroup max={max} min={min} />)
                  : [<code className="hidden">Error: forecast undefined!</code>]
              }
            />
            : <SkeletonCarousel rows={2} cols={forecastDays} />
        }

        {/* 
          *
          * RAIN 
          *
          */}
        <p className="text-start text-sm font-bold">Rain</p>

        {
          forecast != undefined
            ? <Carousel ref={(el) => registerCarousel(el)} onScroll={(e) => handleCarouselScroll(e.target as HTMLDivElement)} items={
              forecast != undefined
                ? indicesArray(forecastDays).map((idx) =>
                  <RainGroup
                    precipitationProbabilityMean={forecast?.daily.precipitationProbabilityMean[idx]}
                    weatherCode={forecast?.daily.weatherCode[idx]} />
                )
                : [<code className="hidden">Error: forecast undefined!</code>]
            } />
            : <SkeletonCarousel rows={2} cols={forecastDays} />
        }

        {/* 
          *
          * WIND 
          *
          */}
        <p className="text-start text-sm font-bold">Wind (kt)</p>

        {
          forecast != undefined
            ? <Carousel ref={(el) => registerCarousel(el)} onScroll={(e) => handleCarouselScroll(e.target as HTMLDivElement)} items={
              forecast != undefined
                ? indicesArray(forecastDays).map(
                  idx => <WindGroup
                    bearing={forecast?.daily.windDirection10mDominant[idx]}
                    maxSpeed={forecast?.daily.windSpeed10mMax[idx]}
                    gusts={forecast?.daily.windGusts10mMax[idx]}
                  />
                )
                : [<code className="hidden">Error: forecast undefined</code>]
            } />
            : <SkeletonCarousel rows={4} cols={forecastDays} />
        }
      </div >
    </>
  )
}

export default App
